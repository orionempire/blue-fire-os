/**************************************************************************
 *	bluefire-os
 *	Version: 00.00.00
 *	Author: David Davidson
 *	Name: interrupt_handler.c
 *	Created: Jan 30, 2012
 *	Purpose:
 *  Usage:
***************************************************************************/
#include <common_include.h>

//intialize to zero
isr_t interrupt_handlers[256];

/*
void interrupt_handler_middle(irq_context_t *context) {
	// Check if this interrupt involved the slave. This was set in os/interrupt_controller/reprogram_PIC_8259
	if (context->IRQ >= 0x28) {
		//Signal a EOI (end of interrupt) by sending a reset signal to the PICs
		outport08(SLAVE_8259_COMMAND_PORT, END_OF_INTERRUPT);
	}
	// we always send one to the master
	outport08(MASTER_8259_COMMAND_PORT, END_OF_INTERRUPT);

	if (interrupt_handlers[context->IRQ] != NULL) {
		isr_t handler = interrupt_handlers[context->IRQ];
		handler(context);
	} else {
    	kprintf("Un-handled interrupt: ->%x\n",context->IRQ);
    	PANIC("Un-handled interrupt");
    }

}*/

void interrupt_handler_middle(irq_context_t *context) {

	// Check if this interrupt involved the slave. This was set in os/interrupt_controller/reprogram_PIC_8259
	if (context->IRQ >= 0x28) {
		//Signal a EOI (end of interrupt) by sending a reset signal to the PICs
		outport08(SLAVE_8259_COMMAND_PORT, END_OF_INTERRUPT);
	}
	// we always send one to the master
	outport08(MASTER_8259_COMMAND_PORT, END_OF_INTERRUPT);

	if (interrupt_handlers[context->IRQ] != NULL) {
		kprintf("handled interrupt: ->%x\n",context->IRQ);
		PANIC("handled interrupt");
	} else {
    	kprintf("Un-handled interrupt: ->%x\n",context->IRQ);
    	PANIC("Un-handled interrupt");
    }

}

void disable_IRQ(u08int irq) {
	static u08int mask;

	if (irq > NUMBER_ALLOCATED_IRQ) {
		return;
	}

	if (irq < 8) {		// Master
		mask = inport08(MASTER_8259_REGISTER_PORT);
		mask |= 1 << irq;
		outport08(MASTER_8259_REGISTER_PORT, mask);
	} else {			// Slave
		mask = inport08(SLAVE_8259_REGISTER_PORT);
		mask |= 1 << (irq - 8);
		outport08(SLAVE_8259_REGISTER_PORT, mask);
	}
}

void enable_IRQ(u08int irq) {
	static u08int mask;

	if (irq > NUMBER_ALLOCATED_IRQ) {
		return;
	}

	if (irq < 8) {	// Master
		mask = inport08(MASTER_8259_REGISTER_PORT);
		mask &= ~(1 << irq);
		outport08(MASTER_8259_REGISTER_PORT, mask);
	} else {		// Slave
		mask = inport08(SLAVE_8259_REGISTER_PORT);
		mask &= ~(1 << (irq - 8));
		outport08(SLAVE_8259_REGISTER_PORT, mask);
	}
}

void register_interrupt_handler(u08int irq, isr_t handler) {
	u32int flags;

	if ( irq > NUMBER_ALLOCATED_IRQ ) {
			return;
	}

	disable_and_save_interrupts(flags);

    interrupt_handlers[irq] = handler;
    enable_IRQ(irq);

	restore_interrupts(flags);
}


void unregister_interrupt_handler(u08int irq) {
	u32int flags;

	if ( irq > NUMBER_ALLOCATED_IRQ ) {
			return;
	}

	disable_and_save_interrupts(flags);

    interrupt_handlers[irq] = NULL;
    disable_IRQ(irq);

	restore_interrupts(flags);
}
