/**************************************************************************
 *	bluefire-os
 *	Version: 00.00.00
 *	Author: David Davidson
 *	Name: exception_handler.c
 *	Created: Jan 30, 2012
 *	Purpose:
 *  Usage:
***************************************************************************/
#include <common_include.h>

// Page fault panic flag
s32int pf_panic;

static __INLINE__ void dump_stack( exc_context_t *c )
{
	uint32_t *esp = (uint32_t *)curr_task->pl0_stack;
	int i = 0;

	while (esp < (uint32_t *)c) {
		if ((*esp >= K_VIR_START) && (*esp < K_HEAP_START)) {
			printk(KERN_WARNING "[ %p ] = %p\n", esp, *esp);
			if (++i >= 12)
				break;
		}
		esp++;
	}
}

static void dump_registers( exc_context_t *c ) {
	register u16int ss, fs, gs;
	register u32int cr0, cr2, cr3, cr4;

	//dump_stack(c);
	panic("stackdump not yet implemented");

	// Save stack segment register.
	__asm__ __volatile__ ("movw %%ss, %0" : "=&r"(ss) : );

	// Save %fs and %gs registers.
	__asm__ __volatile__ ("movw %%fs, %0" : "=m"(fs) :);
	__asm__ __volatile__ ("movw %%gs, %0" : "=m"(gs) :);

	// Save control registers.
	__asm__ __volatile__ ("mov %%cr0, %0" : "=&r"(cr0) : );
	__asm__ __volatile__ ("mov %%cr2, %0" : "=&r"(cr2) : );
	__asm__ __volatile__ ("mov %%cr3, %0" : "=&r"(cr3) : );
	__asm__ __volatile__ ("mov %%cr2, %0" : "=&r"(cr4) : );

	// Dump registers.
	kprintf("\neax = %#010x  ds = %#010x  cr0 = %#010x  esp    = %#010x", c->eax, (u16int)(c->ds), cr0, c);
	kprintf("\nebx = %#010x  es = %#010x  cr2 = %#010x  ebp    = %#010x", c->ebx, (u16int)(c->es), cr2, c->ebp);
	kprintf("\necx = %#010x  fs = %#010x  cr3 = %#010x  eip    = %#010x", c->ecx, (u16int)(fs), cr3, c->eip);
	kprintf("\nedx = %#010x  gs = %#010x  cr4 = %#010x  eflags = %#010x", c->edx, (u16int)(gs), cr4, c->eflags);
	kprintf("\nesi = %#010x  ss = %#010x  exc = %#010x", c->esi, (u16int)(ss), c->EXC);
	kprintf("\nedi = %#010x  cs = %#010x  err = %#010x", c->edi, (u16int)(c->cs), c->err_code);
}

void default_exception(exc_context_t *context)
{
	switch (context->EXC)	{
		case 0x00:
			kprintf("\nException 00: DIVISION BY ZERO\n");
		break;

		case 0x01:
			kprintf("\nException 01: DEBUG EXCEPTION DETECTED\n");
		break;

		case 0x02:
			kprintf("\nException 02: NON MASKABLE INTERRUPT\n");
		break;

		case 0x03:
			kprintf("\nException 03: BREAKPOINT INSTRUCTION DETECTED\n");
			dump_registers(context);
			//printk(KERN_WARNING "\nBreakpoint from task [%s] (%i)\n", get_pname(), get_pid());
			panic("Breakpoint not yet implemented");
			// After a breakpoint we can restore execution.
			return;
		break;

		case 0x04:
			kprintf("\nException 04: INTO DETECTED OVERFLOW\n");
		break;

		case 0x05:
			kprintf("\nException 05: BOUND RANGE EXCEEDED\n");
		break;

		case 0x06:
			kprintf("\nException 06: INVALID OPCODE\n");
		break;

		case 0x07:
			kprintf("\nException 07: PROCESSOR EXTENSION NOT AVAILABLE\n");
		break;

		case 0x08:
			kprintf("\nException 08: DOUBLE FAULT DETECTED\n");
		break;

		case 0x09:
			kprintf("\nException 09: PROCESSOR EXTENSION PROTECTION FAULT\n");
		break;

		case 0x0A:
			kprintf("\nException 0A: INVALID TASK STATE SEGMENT\n");
		break;

		case 0x0B:
			kprintf("\nException 0B: SEGMENT NOT PRESENT\n");
		break;

		case 0x0C:
			kprintf("\nException 0C: STACK FAULT\n");
		break;

		case 0x0D:
			if ((context->eflags & EFLAGS_VM) == EFLAGS_VM) {
				//v86_monitor();
				panic("v86_monitor not yet implemented");
				return;
			} else {
				printf("\n\rException 0D: GENERAL PROTECTION FAULT\n\r");
			}
		break;

		case 0x0E:
			u32int cr2;
			__asm__ __volatile__ ("movl %%cr2, %0" : "=r"(cr2) : );

			if ((context->err_code & P_PRESENT) != P_PRESENT) {
				// page_fault_handler(context->err_code, cr2, &pf_panic);
				if (!pf_panic) {
					return;
				} else {
					kprintf("\nException 0E: PAGE FAULT (Out of memory)!\n");
				}
			} else {
				kprintf(	"\nException 0E: PAGE FAULT  (page level protection violation)!\n");
			}
		break;

		case 0x0F:
			kprintf("\nException 0F: UNKNOWN EXCEPTION\n");
		break;

		default:
			kprintf("\nException #%X: UNEXPECTED !!!\n", (u32int)context->EXC);
		break;
	}

	// Dump the CPU registers.
	dump_registers(context);
	panic();
}
