;**********************************************************
;	bluefire-os
;	Version: 00.00.03
;	Author: David Davidson
;	Name: load_kernel.asm
;	Last update: 2011-11-20
;	Purpose: 
;***********************************************************


; ------ The logical description of a floppy ------


; ------ The physical description of a floppy ------
; The constants that represent the structure of a floppy drive
cst_drive_number			DB	0		; We only support floppy drive A
cst_heads_per_cylinder		DW	2		; A floppy can only have one plater (height of data)
cst_sectors_per_track		DW	18		; A floppy has fixed amt of sectors on a track	(width of data)
cst_bytes_per_sector		DW 	512		; evrey sector has 512 bytes init (density of data)

; ------ Memory locations used as variables ------
;Variables used to return values from function LBACHS
calculated_sector 			DB 0x00
calculated_head   			DB 0x00
calculated_cylinder			DB 0x00

; The constants that represent where we put the kernel on the floppy in floppy sectors.
;cst_kernel_floppy_sector 	DW	800
;cst_kernel_sector_count		DW	2048

; ------ Memory locations used as counters ------
var_current_disk_sector			DW 800
var_current_buffer_segment		DW 0
var_sector_groups_left_to_load	DW 0xF


load_kernel:

	;mov		cx, 0x11
	;push	cx

.load_kenel_loop:
	mov		ax, 0x1000
	mov		es, ax
	mov		bx, 0x0000
	mov		ax, [var_current_disk_sector]
	mov		cx, 128

	call	read_sectors

	mov		ax, [var_current_buffer_segment]
	mov		es, ax
	mov 	ax, 0
	mov		ds, ax
	mov		esi, 0x10000
	mov		edi, 0x100000
	mov		ecx, 0x10000
	a32 	rep	 movsb

	;inc counters
	add	word [var_current_disk_sector], 128
	add word [var_current_buffer_segment], 1000

	;check iteration
	;pop		cx
	;dec		cx
	;push 	cx
	dec		word [var_sector_groups_left_to_load]
	mov		cx,  [var_sector_groups_left_to_load]
	loop .load_kenel_loop


	;pop	cx
	ret


;mov ax, [var_current_disk_sector]
	;add	ax, 128
	;mov [var_current_disk_sector], ax


;mov ax, [var_current_buffer_segment]
	;add ax, 1000
	;mov [var_current_buffer_segment], ax

;***********************************************************
;	read_sectors:
;	-> AX 		=> Starting Sector
;	-> CX 		=> Amount of sectors to read
;				The buffer is segment limited so
;				must be less then or equal to 128 or buffer
;				will wrap over.
;	-> ES:BX 	=> Buffer to read to
;***********************************************************
read_sectors:
	.read_sectors_start:
		mov		di,0x0005						; Five retries in case of error
	.sector_loop:
		push 	ax								; Save the registers that we are going to use.
		push 	bx
		push 	cx
		call LBACHS								; Calculate what the starting sector is
		mov     ah, 0x02						; 02 Bios read sector function
		mov     al, 0x01 						; Read one sector at a time
		mov     ch, BYTE [calculated_cylinder]	; cylinder as returned by LBACHS
        mov     cl, BYTE [calculated_sector]	; sector as returned by LBACHS
        mov     dh, BYTE [calculated_head]		; head as returned by LBACHS
        mov     dl, BYTE [cst_drive_number]		; drive is always 0
		int     0x13							; invoke BIOS 0x13 AH=0x02
		jnc     .success                        ; test carry flag against a read error
		xor     ax, ax							; 0 is BIOS reset disk
		int     0x13							; invoke BIOS 0x13 AH=0x00
		dec     di								; decrement error counter
		pop     cx
		pop     bx
		pop     ax
		jnz     .sector_loop 					; if less the 5 tries, attempt to read again
		call 	fatal_failure
	.success:
		mov     si, cst_msg_progress
		call    print
		pop     cx
		pop     bx
		pop     ax
		add     bx, WORD [cst_bytes_per_sector] ; queue next buffer
		inc     ax                              ; queue next sector
		loop    .read_sectors_start             ; Decreases CX and jums if not zero.
		ret


;***********************************************************
; 	LBACHS
;	Convert LBA to CHS
; 	AX -> LBA Address to convert
;
;	Returns <-
; 		calculated_sector 	= (logical sector mod sectors per track) + 1
; 		calculated_head   	= (logical sector / sectors per track) MOD number of heads
; 		calculated_cylinder = logical sector / (sectors per track * number of heads)
;
;***********************************************************
LBACHS:
    xor     dx, dx                              ; Zero out dx
    div     WORD [cst_sectors_per_track]		; Calculate sector against DX:AX store quotient->AX remainder->DX
    inc     dl                                  ; Adjust for sector 0
    mov     BYTE [calculated_sector], dl		; Store the result.
    xor     dx, dx                              ; Zero out dx
    div     WORD [cst_heads_per_cylinder]		; calculate sector against DX:AX store quotient->AX remainder->DX
    mov     BYTE [calculated_head], dl			; Store the result.
    mov     BYTE [calculated_cylinder], al		; Store the result.
	ret
