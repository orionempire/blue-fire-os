# gdb debugger init script.
# used to format gdb output from bochs into a usable format.
# based on gdbinit8 from https://reverse.put.as/gdbinit/

# __________________gdb options_________________
# set to 1 to enable 64bits target by default (32bits is the default)
set $64BITS = 0
# set to 0 if you have problems with the colorized prompt - reported by Plouj with Ubuntu gdb 7.2
set $COLOUREDPROMPT = 1
# Colour the first line of the disassembly - default is green, if you want to change it search for
# SETCOLOUR1STLINE and modify it :-)
set $SETCOLOUR1STLINE = 0
# set to 0 to remove display of objectivec messages (default is 1)
set $SHOWOBJECTIVEC = 1
# set to 0 to remove display of cpu registers (default is 1)
set $SHOWCPUREGISTERS = 1
# set to 1 to enable display of stack (default is 0)
set $SHOWSTACK = 0
# set to 1 to enable display of data window (default is 0)
set $SHOWDATAWIN = 0
# set to 0 to disable coloured display of changed registers
set $SHOWREGCHANGES = 1
# set to 1 so skip command to execute the instruction at the new location
# by default it EIP/RIP will be modified and update the new context but not execute the instruction
set $SKIPEXECUTE = 0
# if $SKIPEXECUTE is 1 configure the type of execution
# 1 = use stepo (do not get into calls), 0 = use stepi (step into calls)
set $SKIPSTEP = 1
# x86 disassembly flavor: 0 for Intel, 1 for AT&T
set $X86FLAVOR = 0

set confirm off
set verbose off

if $COLOUREDPROMPT == 1
	set prompt \033[31mgdb$ \033[0m
end

set output-radix 0x10
set input-radix 0x10

# These make gdb never pause in its output
set height 0
set width 0

set $SHOW_CONTEXT = 1
set $SHOW_NEST_INSN = 0

set $CONTEXTSIZE_STACK = 6
set $CONTEXTSIZE_DATA  = 8
set $CONTEXTSIZE_CODE  = 8

# __________________end gdb options_________________

#Initialize these variables else comparisons will fail for colouring
# we must initialize all of them at once, 32 and 64 bits, and ARM.
set $oldrax = 0
set $oldrbx = 0
set $oldrcx = 0
set $oldrdx = 0
set $oldrsi = 0
set $oldrdi = 0
set $oldrbp = 0
set $oldrsp = 0

# used by ptraceme/rptraceme
set $ptrace_bpnum = 0

# ______________window size control___________
define contextsize-stack
    if $argc != 1
        help contextsize-stack
    else
        set $CONTEXTSIZE_STACK = $arg0
    end
end
document contextsize-stack
Set stack dump window size to NUM lines.
Usage: contextsize-stack NUM
end


define contextsize-data
    if $argc != 1
        help contextsize-data
    else
        set $CONTEXTSIZE_DATA = $arg0
    end
end
document contextsize-data
Set data dump window size to NUM lines.
Usage: contextsize-data NUM
end


define contextsize-code
    if $argc != 1
        help contextsize-code
    else
        set $CONTEXTSIZE_CODE = $arg0
    end
end
document contextsize-code
Set code window size to NUM lines.
Usage: contextsize-code NUM
end

# _____________breakpoint aliases_____________
define bpl
    info breakpoints
end
document bpl
List all breakpoints.
end

define bp
    if $argc != 1
        help bp
    else
        break $arg0
    end
end
document bp
Set breakpoint.
Usage: bp LOCATION
LOCATION may be a line number, function name, or "*" and an address.
To break on a symbol you must enclose symbol name inside "".
Example:
bp "[NSControl stringValue]"
Or else you can use directly the break command (break [NSControl stringValue])
end


define bpc 
    if $argc != 1
        help bpc
    else
        clear $arg0
    end
end
document bpc
Clear breakpoint.
Usage: bpc LOCATION
LOCATION may be a line number, function name, or "*" and an address.
end


define bpe
    if $argc != 1
        help bpe
    else
        enable $arg0
    end
end
document bpe
Enable breakpoint with number NUM.
Usage: bpe NUM
end


define bpd
    if $argc != 1
        help bpd
    else
        disable $arg0
    end
end
document bpd
Disable breakpoint with number NUM.
Usage: bpd NUM
end


define bpt
    if $argc != 1
        help bpt
    else
        tbreak $arg0
    end
end
document bpt
Set a temporary breakpoint.
This breakpoint will be automatically deleted when hit!.
Usage: bpt LOCATION
LOCATION may be a line number, function name, or "*" and an address.
end


define bpm
    if $argc != 1
        help bpm
    else
        awatch $arg0
    end
end
document bpm
Set a read/write breakpoint on EXPRESSION, e.g. *address.
Usage: bpm EXPRESSION
end


define bhb
    if $argc != 1
        help bhb
    else
        hb $arg0
    end
end
document bhb
Set hardware assisted breakpoint.
Usage: bhb LOCATION
LOCATION may be a line number, function name, or "*" and an address.
end

define bht
    if $argc != 1
        help bht
    else
        thbreak $arg0
    end
end
document bht
Set a temporary hardware breakpoint.
This breakpoint will be automatically deleted when hit!
Usage: bht LOCATION
LOCATION may be a line number, function name, or "*" and an address.
end

# ______________process information____________
define argv
    show args
end
document argv
Print program arguments.
end


define stack
    if $argc == 0
        info stack
    end
    if $argc == 1
        info stack $arg0
    end
    if $argc > 1
        help stack
    end
end
document stack
Print backtrace of the call stack, or innermost COUNT frames.
Usage: stack <COUNT>
end


define frame
    info frame
    info args
    info locals
end
document frame
Print stack frame.
end

define flagsx86
    # OF (overflow) flag
    if (($eflags >> 0xB) & 1)
        printf "O "
        set $_of_flag = 1
    else
        printf "o "
        set $_of_flag = 0
    end
    # DF (direction) flag
    if (($eflags >> 0xA) & 1)
        printf "D "
    else
        printf "d "
    end
    # IF (interrupt enable) flag
    if (($eflags >> 9) & 1)
        printf "I "
    else
        printf "i "
    end
    # TF (trap) flag
    if (($eflags >> 8) & 1)
        printf "T "
    else
        printf "t "
    end
    # SF (sign) flag
    if (($eflags >> 7) & 1)
        printf "S "
        set $_sf_flag = 1
    else
        printf "s "
        set $_sf_flag = 0
    end
    # ZF (zero) flag
    if (($eflags >> 6) & 1)
        printf "Z "
    	set $_zf_flag = 1
    else
        printf "z "
	    set $_zf_flag = 0
    end
    # AF (adjust) flag
    if (($eflags >> 4) & 1)
        printf "A "
    else
        printf "a "
    end
    # PF (parity) flag
    if (($eflags >> 2) & 1)
        printf "P "
	    set $_pf_flag = 1
    else
        printf "p "
    	set $_pf_flag = 0
    end
    # CF (carry) flag
    if ($eflags & 1)
        printf "C "
	    set $_cf_flag = 1
    else
        printf "c "
    	set $_cf_flag = 0
    end
    printf "\n"
end
document flagsx86
Auxiliary function to set X86/X64 cpu flags.
end


define flags
	flagsx86
end
document flags
Print flags register.
end

define eflags
        printf "     OF <%d>  DF <%d>  IF <%d>  TF <%d>",\
               (($eflags >> 0xB) & 1), (($eflags >> 0xA) & 1), \
               (($eflags >> 9) & 1), (($eflags >> 8) & 1)
        printf "  SF <%d>  ZF <%d>  AF <%d>  PF <%d>  CF <%d>\n",\
               (($eflags >> 7) & 1), (($eflags >> 6) & 1),\
               (($eflags >> 4) & 1), (($eflags >> 2) & 1), ($eflags & 1)
        printf "     ID <%d>  VIP <%d> VIF <%d> AC <%d>",\
               (($eflags >> 0x15) & 1), (($eflags >> 0x14) & 1), \
               (($eflags >> 0x13) & 1), (($eflags >> 0x12) & 1)
        printf "  VM <%d>  RF <%d>  NT <%d>  IOPL <%d>\n",\
               (($eflags >> 0x11) & 1), (($eflags >> 0x10) & 1),\
               (($eflags >> 0xE) & 1), (($eflags >> 0xC) & 3)
end
document eflags
Print eflags register.
end

define cpsr
	eflags
end
document cpsr
Print cpsr register.
end


define regx86
    printf "  "
    # EAX
    echo \033[32m
	printf "EAX:"
    if ($eax != $oldeax && $SHOWREGCHANGES == 1)
   	 	echo \033[31m   	 	
   	else
   	 	echo \033[0m
   	end
   	printf " 0x%08X  ", $eax
   	# EBX
    echo \033[32m
   	printf "EBX:"
   	if ($ebx != $oldebx && $SHOWREGCHANGES == 1) 
	    echo \033[31m   		
   	else
	    echo \033[0m
   	end
   	printf " 0x%08X  ", $ebx
   	# ECX
    echo \033[32m
   	printf "ECX:"
   	if ($ecx != $oldecx && $SHOWREGCHANGES == 1)
	    echo \033[31m	    
	else
	    echo \033[0m
	end
	printf " 0x%08X  ", $ecx
	# EDX
	if ($edx != $oldedx && $SHOWREGCHANGES == 1)
	    echo \033[32m
    	printf "EDX:"
	    echo \033[31m
	    printf " 0x%08X  ", $edx
	else
	    echo \033[32m
    	printf "EDX:"
	    echo \033[0m
	    printf " 0x%08X  ", $edx
	end
    echo \033[1m\033[4m\033[31m
    flags
    echo \033[0m
    printf "  "
    # ESI
	echo \033[32m
    printf "ESI:"
    if ($esi != $oldesi && $SHOWREGCHANGES == 1)
	    echo \033[31m	    
	else
	    echo \033[0m
	end
	printf " 0x%08X  ", $esi
	# EDI
	echo \033[32m
    printf "EDI:"
	if ($edi != $oldedi && $SHOWREGCHANGES == 1)
	    echo \033[31m	    
	else
	    echo \033[0m
	end
	printf " 0x%08X  ", $edi
	# EBP
	echo \033[32m
	printf "EBP:"
	if ($ebp != $oldebp && $SHOWREGCHANGES == 1)
	    echo \033[31m
	else
	    echo \033[0m
	end
	printf " 0x%08X  ", $ebp
	# ESP
	echo \033[32m
    printf "ESP:"
	if ($esp != $oldesp && $SHOWREGCHANGES == 1)
	    echo \033[31m	    
	else
	    echo \033[0m
    end
    printf " 0x%08X  ", $esp
    # EIP
    echo \033[32m
    printf "EIP:"
    echo \033[0m
    printf " 0x%08X\n  ", $eip
    echo \033[32m
    printf "CS:"
    echo \033[0m
    printf " %04X  ", $cs
    echo \033[32m
    printf "DS:"
    echo \033[0m
    printf " %04X  ", $ds
    echo \033[32m
    printf "ES:"
    echo \033[0m
    printf " %04X  ", $es
    echo \033[32m
    printf "FS:"
    echo \033[0m
    printf " %04X  ", $fs
    echo \033[32m
    printf "GS:"
    echo \033[0m
    printf " %04X  ", $gs
    echo \033[32m
    printf "SS:"
    echo \033[0m
    printf " %04X", $ss
    echo \033[0m
end
document regx86
Auxiliary function to display X86 registers.
end


define reg
        regx86
        # call smallregisters
	    smallregisters
        # display conditional jump routine
        dumpjump
        printf "\n"
        if ($SHOWREGCHANGES == 1)
	        	set $oldeax = $eax
		    	set $oldebx = $ebx
			    set $oldecx = $ecx
    			set $oldedx = $edx
	    		set $oldesi = $esi
		    	set $oldedi = $edi
			    set $oldebp = $ebp
			    set $oldesp = $esp
    		end
	    end
    end
end
document reg
Print CPU registers.
end


define smallregisters
	    # from eax
    	set $ax = $eax & 0xffff
    	set $al = $ax & 0xff
    	set $ah = $ax >> 8
	    # from ebx
    	set $bx = $ebx & 0xffff
    	set $bl = $bx & 0xff
    	set $bh = $bx >> 8
    	# from ecx
    	set $cx = $ecx & 0xffff
    	set $cl = $cx & 0xff
    	set $ch = $cx >> 8
    	# from edx
    	set $dx = $edx & 0xffff
    	set $dl = $dx & 0xff
	    set $dh = $dx >> 8
    	# from esi
    	set $si = $esi & 0xffff
    	# from edi
	    set $di = $edi & 0xffff		
end
document smallregisters
Create the 16 and 8 bit cpu registers (gdb doesn't have them by default).
And 32bits if we are dealing with 64bits binaries.
end


# _____________bluefire specific commands_____________
set archi i386:x86-64
#connect to already running bochs
target remote localhost:1234
#set a brake at the beginnging of the bootloader 
bp *0x7c00
#continue until then
c