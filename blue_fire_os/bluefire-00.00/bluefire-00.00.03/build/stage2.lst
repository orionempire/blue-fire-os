     1                                  ;**********************************************************
     2                                  ;	bluefire-os
     3                                  ;	Version: 00.00.02
     4                                  ;	Author: David Davidson
     5                                  ;	Name: stage2.asm
     6                                  ;	Last update: 2011-11-20
     7                                  ;***********************************************************
     8                                  
     9                                  ;***********************************************************
    10                                  ;	As in stage 1 we are still generating 16 bit code as
    11                                  ;	it will be running in real mode for now
    12                                  ;***********************************************************
    13                                  bits 16
    14                                  
    15                                  ;***********************************************************
    16                                  ;	To keep things interesting we are going to use the other
    17                                  ;	addressing technique. We are going to set our segment registers
    18                                  ;	to 0 and have all addresses in the code prefix with 0x8000
    19                                  ;***********************************************************
    20                                  org 0x8000
    21                                  
    22 00000000 EB35                    start:	jmp main	;jump over to first byte of executable code
    23                                  
    24                                  ;0x0A ascii for next line.  0x0D cursor to the beggining of the line.
    25 00000002 0D0A4C6F6164696E67-     cst_msg_loading 			DB 0x0D, 0x0A, "Loading Stage 2...", 0x0D, 0x0A, 0x00
    26 0000000B 20537461676520322E-
    27 00000014 2E2E0D0A00         
    28                                  
    29                                  
    30                                  ;***********************************************************
    31                                  ; Global Descriptor Register (GDR)
    32                                  ;***********************************************************
    33                                  gdtr:
    34 00000019 1700                    	dw end_of_gdt - gdt_data - 1 	; limit (Size of GDT)
    35 0000001B [1F000000]              	dd gdt_data 			; base of GDT
    36                                  ;***********************************************************
    37                                  ; Global Descriptor Table (GDT)
    38                                  ;***********************************************************
    39                                  gdt_data:
    40                                  ; Dummy descriptor			; 0x00
    41 0000001F 0000                    	DW 0					; Limit low (bytes 15:0)
    42 00000021 0000                    	DW 0					; Base low (bytes 15:0)
    43 00000023 00                      	DB 0					; Base middle (bytes 23:16)
    44 00000024 00                      	DB 0					; Access byte (descriptor type)
    45 00000025 00                      	DB 0					; Flags, Limit middle (bytes 19:16)
    46 00000026 00                      	DB 0					; Base high (bytes 31:24)
    47                                  
    48                                  ; boot code:				; code descriptor
    49 00000027 FFFF                    	DW 0xFFFF           	; Limit (bytes 15:0)
    50 00000029 0000                    	DW 0                	; Base  (bytes 15:0)
    51 0000002B 00                      	DB 0                	; Base  (bytes 23:16)
    52 0000002C 9A                      	DB 0b10011010        	; access  = Present, Ring 0, 1, Executable, Direction, Readable, Unaccessed (1,00,1,1110 -> 9A)
    53 0000002D CF                      	DB 0b11001111        	; granularity = 4KB Granularity, 32bit segment size, reserved, reserved (AVL), Limit (bytes 19:16) (1,1,0,0,1111 - > CF)
    54 0000002E 00                      	DB 0                	; Base  (bytes 31:24)
    55                                  
    56                                  ; boot data:	        	; data descriptor
    57 0000002F FFFF                    	DW 0xFFFF           	; Limit (bytes 15:0)
    58 00000031 0000                    	DW 0                	; Base  (bytes 15:0)
    59 00000033 00                      	DB 0                	; Base  (bytes 23:16)
    60 00000034 92                      	DB 0b10010010        	; access  = Present, Ring 0, 1, Not Executable, No Direction, Readable, Unaccessed (1,00,1,0010 -> 92)
    61 00000035 CF                      	DB 0b11001111        	; granularity = 4KB Granularity, 32bit segment size, reserved, reserved (AVL), Limit (bytes 19:16) (1,1,0,0,1111 - > CF)
    62 00000036 00                      	DB 0                	; Base  (bytes 31:24)
    63                                  end_of_gdt:
    64                                  
    65                                  main:
    66 00000037 FA                      	cli						; clear interrupts
    67                                  
    68                                  ;***********************************************************
    69                                  ;	Set the segment registers back to 0x0000 as aformentioned
    70                                  ;	As we are now using the org directive to hard code the address offsets
    71                                  ;	The stack is staying at 000F:FFFF and should be empty at this point
    72                                  ;	but we set it again to be safe
    73                                  ;***********************************************************
    74 00000038 31C0                    	xor		ax, ax			; null segments
    75 0000003A 8ED8                    	mov		ds, ax
    76 0000003C 8EC0                    	mov		es, ax
    77                                  
    78 0000003E B80090                  	mov 	ax, 0x9000
    79 00000041 8ED0                    	mov		ss, ax
    80 00000043 BCFFFF                  	mov		sp, 0xFFFF
    81 00000046 FB                      	sti						; restore interupts we need them before we can make any bios call
    82                                  
    83                                  ;***********************************************************
    84                                  ;	Enable the A20 line
    85                                  ;	Allows more than 1MB to be accessed
    86                                  ;***********************************************************
    87 00000047 E81B00                  	call enable_a20_keyboard_out
    88                                  
    89                                  ;***********************************************************
    90                                  ;	Display welcome message
    91                                  ;***********************************************************
    92 0000004A BE[0200]                	mov		si, cst_msg_loading
    93 0000004D E80900                  	call	print
    94                                  
    95                                  ;***********************************************************
    96                                  ;		Load Descriptor table
    97                                  ;***********************************************************
    98                                  	; disable interrupts for the final time. We cant start them
    99                                  	; again until the kernel has set up a interupt table
   100 00000050 FA                      	cli
   101 00000051 0F0116[1900]            	lgdt 	[gdtr]        	; load GDT into GDTR
   102 00000056 FB                      	sti		;temp
   103                                  
   104                                  end:
   105 00000057 EBFE                    	jmp 	end				;stop here for now
   106                                  
   107                                  
   108                                  ;***********************************************************
   109                                  ;	print:
   110                                  ;	- Prints a string
   111                                  ;	assumes
   112                                  ;	- address of first character is in DS:SI
   113                                  ;	last character is /0 (NULL)
   114                                  ;***********************************************************
   115                                  print:
   116 00000059 AC                      	lodsb					; Load DS:SI into AL for proccessing
   117 0000005A 08C0                    	or		al, al 			; this can only set the zero flag if AL is NULL
   118 0000005C 7406                    	jz		end_print		; if zero flag is set
   119 0000005E B40E                    	mov		ah, 0eh			; Bios paramaeter
   120 00000060 CD10                    	int		10h				; Bios function
   121 00000062 EBF5                    	jmp		print			; repeat until null terminator is found.
   122                                  end_print:
   123 00000064 C3                      	ret
   124                                  
   125                                  ;***********************************************************
   126                                  ;		enable_a20_keyboard_out:
   127                                  ;		- enable the a20 line
   128                                  ;		- Uses the keyboard controller out port method
   129                                  ;***********************************************************
   130                                  enable_a20_keyboard_out:
   131 00000065 FA                      	cli						;stop interupts
   132 00000066 60                      	pusha					;save state of all registers
   133 00000067 E82F00                  	call 	wait_for_clear_input
   134 0000006A B0AD                    	mov     al,0xAD
   135 0000006C E664                    	out     0x64,al			; disable the keyboard
   136 0000006E E82800                  	call 	wait_for_clear_input
   137                                  
   138 00000071 B0D0                    	mov     al,0xD0
   139 00000073 E664                    	out     0x64,al			; tell controller to read key board output port
   140 00000075 E82800                  	call    wait_for_clear_output
   141                                  
   142 00000078 E460                    	in      al,0x60
   143 0000007A 6650                    	push    eax				; get output port data and store it
   144 0000007C E81A00                  	call 	wait_for_clear_input
   145                                  
   146 0000007F B0D1                    	mov     al,0xD1
   147 00000081 E664                    	out     0x64,al			; tell controller to write to output port
   148 00000083 E81300                  	call 	wait_for_clear_input
   149                                  
   150 00000086 6658                    	pop     eax
   151 00000088 0C02                    	or      al,2			; set bit 1 (enable a20)
   152 0000008A E660                    	out     0x60,al			; write out data back to the output port
   153                                  
   154 0000008C E80A00                  	call 	wait_for_clear_input
   155 0000008F B0AE                    	mov     al,0xAE		; enable the keyboard
   156 00000091 E664                    	out     0x64,al
   157                                  
   158 00000093 E80300                  	call 	wait_for_clear_input
   159 00000096 61                      	popa
   160 00000097 FB                      	sti
   161 00000098 C3                      	ret
   162                                  
   163                                  wait_for_clear_input:	;wait for a clear input buffer
   164 00000099 E464                    	in      al,0x64
   165 0000009B A802                    	test    al,2
   166 0000009D 75FA                    	jnz     wait_for_clear_input
   167 0000009F C3                      	ret
   168                                  
   169                                  wait_for_clear_output:	;wait for a clear output buffer
   170 000000A0 E464                    	in      al,0x64
   171 000000A2 A801                    	test    al,1
   172 000000A4 74FA                    	jz      wait_for_clear_output
   173 000000A6 C3                      	ret
