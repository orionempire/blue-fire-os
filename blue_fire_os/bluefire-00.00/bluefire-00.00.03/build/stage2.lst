     1                                  ;**********************************************************
     2                                  ;	bluefire-os
     3                                  ;	Version: 00.00.02
     4                                  ;	Author: David Davidson
     5                                  ;	Name: stage2.asm
     6                                  ;	Last update: 2011-11-20
     7                                  ;	Purpose: Enable A20 Line, Load GDT, enable protect mode, enable paging.
     8                                  ;		Load a kernel to physical memory location 0x100000
     9                                  ;***********************************************************
    10                                  
    11                                  ;***********************************************************
    12                                  ;	As in stage 1 we are still generating 16 bit code as
    13                                  ;	it will be running in real mode for now
    14                                  ;***********************************************************
    15                                  bits 16
    16                                  
    17                                  ;***********************************************************
    18                                  ;	To keep things interesting we are going to use the other
    19                                  ;	addressing technique. We are going to set our segment registers
    20                                  ;	to 0 and have all addresses in the code prefix with 0x8000
    21                                  ;***********************************************************
    22                                  org 0x8000
    23 00000000 E91E01                  start:	jmp main	;jump over to first byte of executable code
    24                                  
    25                                  %include "load_kernel.asm"
    26                              <1> ;**********************************************************
    27                              <1> ;	bluefire-os
    28                              <1> ;	Version: 00.00.03
    29                              <1> ;	Author: David Davidson
    30                              <1> ;	Name: load_kernel.asm
    31                              <1> ;	Last update: 2011-11-20
    32                              <1> ;	Purpose: To load a kernel from a fixed location on a floppy
    33                              <1> ;			to a fixed location in upper memory.
    34                              <1> ;	Usage: Unreal mode must have been enabled. Memory location 0x10000
    35                              <1> ;			must be availabel for use as a buffer. Kernel must be flat
    36                              <1> ;			arrayed on floppy sectors 800 to 2800
    37                              <1> ;***********************************************************
    38                              <1> 
    39                              <1> 
    40                              <1> ; ------ The physical description of a floppy ------
    41                              <1> ; The constants that represent the structure of a floppy drive
    42 00000003 00                  <1> cst_drive_number			DB	0		; We only support floppy drive A
    43 00000004 0200                <1> cst_heads_per_cylinder		DW	2		; A floppy can only have one plater (height of data)
    44 00000006 1200                <1> cst_sectors_per_track		DW	18		; A floppy has fixed amt of sectors on a track	(width of data)
    45 00000008 0002                <1> cst_bytes_per_sector		DW 	512		; evrey sector has 512 bytes init (density of data)
    46                              <1> 
    47                              <1> ; ------ Memory locations used as variables ------
    48                              <1> ;Variables used to return values from function LBACHS
    49 0000000A 00                  <1> calculated_sector 			DB 0x00
    50 0000000B 00                  <1> calculated_head   			DB 0x00
    51 0000000C 00                  <1> calculated_cylinder			DB 0x00
    52                              <1> 
    53                              <1> ; ------ Memory locations used as counters ------
    54                              <1> ; Starting location of kernel on disk. Fixed by build script.
    55 0000000D 2003                <1> var_current_disk_sector			DW 800
    56                              <1> ; Running counter of where in upper memory the kernel is currently
    57                              <1> ; being loaded. The segment is increased to keep the counter from
    58                              <1> ; increasing past a number that can be handled by 16 bits.
    59 0000000F 0000                <1> var_current_buffer_segment		DW 0
    60                              <1> ; Running counter of how many groups of disk sectors are left to load.
    61 00000011 1000                <1> var_sector_groups_left_to_load	DW 0x10
    62                              <1> ;var_sector_groups_left_to_load	DW 0x2
    63                              <1> 
    64                              <1> 
    65                              <1> load_kernel:
    66                              <1> 	; Since unreal mode is activated the code can access above 1 MB but
    67                              <1> 	; the bois interrupts that are needed to load the data off the disk
    68                              <1> 	; can only be used as if in real mode. So the code Loads
    69                              <1> 	; 16 groups of 125 disk blocks from the floppy to upper memory
    70                              <1> 	; using lower memory for each chunk.
    71                              <1> 	.load_kenel_loop:
    72                              <1> 		; --------------------------------------------------
    73                              <1> 		; Load a group of 125 disk sectors to lower memory
    74                              <1> 		; --------------------------------------------------
    75                              <1> 
    76                              <1> ; TODO -> document memory map
    77                              <1> 		; use 1000:0000(0x10000) as the low memory buffer
    78 00000013 B80010              <1> 		mov		ax, 0x1000
    79 00000016 8EC0                <1> 		mov		es, ax
    80 00000018 BB0000              <1> 		mov		bx, 0x0000
    81                              <1> 		; load the 125 disk sectors we are up to
    82 0000001B A1[0D00]            <1> 		mov		ax, [var_current_disk_sector]
    83 0000001E B97D00              <1> 		mov		cx, 125
    84                              <1> 
    85 00000021 E83500              <1> 		call	read_sectors
    86                              <1> 
    87                              <1> 		; --------------------------------------------------
    88                              <1> 		; Copy the buffer to upper memory
    89                              <1> 		; --------------------------------------------------
    90                              <1> 
    91                              <1> 		; load the current running upper memory address
    92 00000024 A1[0F00]            <1> 		mov		ax, [var_current_buffer_segment]
    93 00000027 8EC0                <1> 		mov		es, ax
    94                              <1> 
    95                              <1> 		; Initalize source segment to be safe
    96 00000029 B80000              <1> 		mov 	ax, 0
    97 0000002C 8ED8                <1> 		mov		ds, ax
    98                              <1> 
    99                              <1> 		; The source is 1000:0000 (0x10000), the destination is es:0x100000
   100 0000002E 66BE00000100        <1> 		mov		esi, 0x10000
   101 00000034 66BF00001000        <1> 		mov		edi, 0x100000
   102                              <1> 		; copy the whole (sector group X sector size (125 x 512 =  0xFA00)) buffer
   103 0000003A 66B900FA0000        <1> 		mov		ecx, 0xFA00
   104                              <1> 		; we are using unreal memory location in real mode so we use the menomic a32
   105                              <1> 		; to generate 32 bit code.
   106 00000040 F367A4              <1> 		a32 	rep	 movsb
   107                              <1> 
   108                              <1> 		;inc counters
   109 00000043 8306[0D00]7D        <1> 		add	word [var_current_disk_sector], 125
   110 00000048 8106[0F00]A00F      <1> 		add word [var_current_buffer_segment], 0xFA0
   111                              <1> 
   112                              <1> 		;check iteration
   113 0000004E 8B0E[1100]          <1> 		mov		cx,  [var_sector_groups_left_to_load]
   114 00000052 FF0E[1100]          <1> 		dec		word [var_sector_groups_left_to_load]
   115 00000056 E2BB                <1> 		loop .load_kenel_loop
   116                              <1> 
   117 00000058 C3                  <1> 	ret
   118                              <1> 
   119                              <1> 
   120                              <1> ;***********************************************************
   121                              <1> ;	read_sectors:
   122                              <1> ;	-> AX 		=> Starting Sector
   123                              <1> ;	-> CX 		=> Amount of sectors to read
   124                              <1> ;				The buffer is segment limited so
   125                              <1> ;				must be less then or equal to 128 or buffer
   126                              <1> ;				will wrap over.
   127                              <1> ;	-> ES:BX 	=> Buffer to read to
   128                              <1> ;***********************************************************
   129                              <1> read_sectors:
   130                              <1> 	.read_sectors_start:
   131 00000059 BF0500              <1> 		mov		di,0x0005						; Five retries in case of error
   132                              <1> 	.sector_loop:
   133 0000005C 50                  <1> 		push 	ax								; Save the registers that we are going to use.
   134 0000005D 53                  <1> 		push 	bx
   135 0000005E 51                  <1> 		push 	cx
   136 0000005F E83600              <1> 		call LBACHS								; Calculate what the starting sector is
   137 00000062 B402                <1> 		mov     ah, 0x02						; 02 Bios read sector function
   138 00000064 B001                <1> 		mov     al, 0x01 						; Read one sector at a time
   139 00000066 8A2E[0C00]          <1> 		mov     ch, BYTE [calculated_cylinder]	; cylinder as returned by LBACHS
   140 0000006A 8A0E[0A00]          <1>         mov     cl, BYTE [calculated_sector]	; sector as returned by LBACHS
   141 0000006E 8A36[0B00]          <1>         mov     dh, BYTE [calculated_head]		; head as returned by LBACHS
   142 00000072 8A16[0300]          <1>         mov     dl, BYTE [cst_drive_number]		; drive is always 0
   143 00000076 CD13                <1> 		int     0x13							; invoke BIOS 0x13 AH=0x02
   144 00000078 730D                <1> 		jnc     .success                        ; test carry flag against a read error
   145 0000007A 31C0                <1> 		xor     ax, ax							; 0 is BIOS reset disk
   146 0000007C CD13                <1> 		int     0x13							; invoke BIOS 0x13 AH=0x00
   147 0000007E 4F                  <1> 		dec     di								; decrement error counter
   148 0000007F 59                  <1> 		pop     cx
   149 00000080 5B                  <1> 		pop     bx
   150 00000081 58                  <1> 		pop     ax
   151 00000082 75D8                <1> 		jnz     .sector_loop 					; if less the 5 tries, attempt to read again
   152 00000084 E8CF00              <1> 		call 	fatal_failure
   153                              <1> 	.success:
   154 00000087 BE[E700]            <1> 		mov     si, cst_msg_progress
   155 0000008A E8D500              <1> 		call    print
   156 0000008D 59                  <1> 		pop     cx
   157 0000008E 5B                  <1> 		pop     bx
   158 0000008F 58                  <1> 		pop     ax
   159 00000090 031E[0800]          <1> 		add     bx, WORD [cst_bytes_per_sector] ; queue next buffer
   160 00000094 40                  <1> 		inc     ax                              ; queue next sector
   161 00000095 E2C2                <1> 		loop    .read_sectors_start             ; Decreases CX and jums if not zero.
   162 00000097 C3                  <1> 		ret
   163                              <1> 
   164                              <1> 
   165                              <1> ;***********************************************************
   166                              <1> ; 	LBACHS
   167                              <1> ;	Convert LBA to CHS
   168                              <1> ; 	AX -> LBA Address to convert
   169                              <1> ;
   170                              <1> ;	Returns <-
   171                              <1> ; 		calculated_sector 	= (logical sector mod sectors per track) + 1
   172                              <1> ; 		calculated_head   	= (logical sector / sectors per track) MOD number of heads
   173                              <1> ; 		calculated_cylinder = logical sector / (sectors per track * number of heads)
   174                              <1> ;
   175                              <1> ;***********************************************************
   176                              <1> LBACHS:
   177 00000098 31D2                <1>     xor     dx, dx                              ; Zero out dx
   178 0000009A F736[0600]          <1>     div     WORD [cst_sectors_per_track]		; Calculate sector against DX:AX store quotient->AX remainder->DX
   179 0000009E FEC2                <1>     inc     dl                                  ; Adjust for sector 0
   180 000000A0 8816[0A00]          <1>     mov     BYTE [calculated_sector], dl		; Store the result.
   181 000000A4 31D2                <1>     xor     dx, dx                              ; Zero out dx
   182 000000A6 F736[0400]          <1>     div     WORD [cst_heads_per_cylinder]		; calculate sector against DX:AX store quotient->AX remainder->DX
   183 000000AA 8816[0B00]          <1>     mov     BYTE [calculated_head], dl			; Store the result.
   184 000000AE A2[0C00]            <1>     mov     BYTE [calculated_cylinder], al		; Store the result.
   185 000000B1 C3                  <1> 	ret
   186                                  
   187                                  ; ------ Mesages ------
   188                                  ;0x0A ascii for next line.  0x0D cursor to the beggining of the line.
   189 000000B2 0D0A4C6F6164696E67-     cst_msg_loading 			DB 0x0D, 0x0A, "Loading Stage 2...", 0x0D, 0x0A, 0x00
   190 000000BB 20537461676520322E-
   191 000000C4 2E2E0D0A00         
   192 000000C9 0D0A57656C6F636D65-     cst_msg_unreal	 			DB 0x0D, 0x0A, "Welocme to unreal mode...", 0x0D, 0x0A, 0x00
   193 000000D2 20746F20756E726561-
   194 000000DB 6C206D6F64652E2E2E-
   195 000000E4 0D0A00             
   196                                  ; print one dot for every disk sector we load
   197 000000E7 2E00                    cst_msg_progress 			DB ".", 0x00
   198                                  ; Fatal
   199 000000E9 0D0A466174616C2046-     cst_msg_fatal_failure  		DB 0x0D, 0x0A, "Fatal Failure.....", 0x0A, 0x00
   200 000000F2 61696C7572652E2E2E-
   201 000000FB 2E2E0A00           
   202                                  
   203                                  ;-------variables--------
   204                                  ; Currently set to 128 MB. If system memory changes it must be hard coded here
   205 000000FF 00000008                var_system_memory_amount	DD	0x8000000
   206                                  ;***********************************************************
   207                                  ; Global Descriptor Register (GDR)
   208                                  ;***********************************************************
   209                                  gdtr:
   210 00000103 1700                    	dw end_of_gdt - gdt_data - 1 	; limit (Size of GDT)
   211 00000105 [09010000]              	dd gdt_data 			; base of GDT
   212                                  ;***********************************************************
   213                                  ; Global Descriptor Table (GDT)
   214                                  ;***********************************************************
   215                                  gdt_data:
   216                                  ; Dummy descriptor			; 0x00
   217 00000109 0000                    	DW 0					; Limit low (bytes 15:0)
   218 0000010B 0000                    	DW 0					; Base low (bytes 15:0)
   219 0000010D 00                      	DB 0					; Base middle (bytes 23:16)
   220 0000010E 00                      	DB 0					; Access byte (descriptor type)
   221 0000010F 00                      	DB 0					; Flags, Limit middle (bytes 19:16)
   222 00000110 00                      	DB 0					; Base high (bytes 31:24)
   223                                  ; boot code:				; code descriptor
   224 00000111 FFFF                    	DW 0xFFFF           	; Limit (bytes 15:0)
   225 00000113 0000                    	DW 0                	; Base  (bytes 15:0)
   226 00000115 00                      	DB 0                	; Base  (bytes 23:16)
   227 00000116 9A                      	DB 0b10011010        	; access  = Present, Ring 0, 1, Executable, Direction, Readable, Unaccessed (1,00,1,1110 -> 9A)
   228 00000117 CF                      	DB 0b11001111        	; granularity = 4KB Granularity, 32bit segment size, reserved, reserved (AVL), Limit (bytes 19:16) (1,1,0,0,1111 - > CF)
   229 00000118 00                      	DB 0                	; Base  (bytes 31:24)
   230                                  ; boot data:	        	; data descriptor
   231 00000119 FFFF                    	DW 0xFFFF           	; Limit (bytes 15:0)
   232 0000011B 0000                    	DW 0                	; Base  (bytes 15:0)
   233 0000011D 00                      	DB 0                	; Base  (bytes 23:16)
   234 0000011E 92                      	DB 0b10010010        	; access  = Present, Ring 0, 1, Not Executable, No Direction, Readable, Unaccessed (1,00,1,0010 -> 92)
   235 0000011F CF                      	DB 0b11001111        	; granularity = 4KB Granularity, 32bit segment size, reserved, reserved (AVL), Limit (bytes 19:16) (1,1,0,0,1111 - > CF)
   236 00000120 00                      	DB 0                	; Base  (bytes 31:24)
   237                                  end_of_gdt:
   238                                  
   239                                  main:
   240 00000121 FA                      	cli						; clear interrupts
   241                                  
   242                                  ;***********************************************************
   243                                  ;	Set the segment registers back to 0x0000 as aformentioned
   244                                  ;	As we are now using the org directive to hard code the address offsets
   245                                  ;	The stack is staying at 000F:FFFF and should be empty at this point
   246                                  ;	but we set it again to be safe
   247                                  ;***********************************************************
   248 00000122 31C0                    	xor		ax, ax			; null segments
   249 00000124 8ED8                    	mov		ds, ax
   250 00000126 8EC0                    	mov		es, ax
   251 00000128 8EE0                    	mov		fs, ax
   252 0000012A 8EE8                    	mov		gs, ax
   253                                  
   254 0000012C B80090                  	mov 	ax, 0x9000
   255 0000012F 8ED0                    	mov		ss, ax
   256 00000131 BCFFFF                  	mov		sp, 0xFFFF
   257 00000134 FB                      	sti						; restore interupts we need them before we can make any bios call
   258                                  
   259                                  ;***********************************************************
   260                                  ;	Display welcome message
   261                                  ;***********************************************************
   262 00000135 BE[B200]                	mov		si, cst_msg_loading
   263 00000138 E82700                  	call	print
   264                                  
   265                                  ;***********************************************************
   266                                  ;	Allow more than 1MB to be accessed
   267                                  ;	Enable the A20 line
   268                                  ;	Enable Unreal mode
   269                                  ;
   270                                  ;***********************************************************
   271 0000013B E83000                  	call 	enable_a20_keyboard_out
   272 0000013E E86100                  	call 	enable_unreal_mode
   273 00000141 BE[C900]                	mov		si, cst_msg_unreal
   274 00000144 E81B00                  	call	print
   275                                  
   276                                  
   277                                  ;***********************************************************
   278                                  ;	Load the kernel into memory
   279                                  ;	Ensure that floppy motor is off
   280                                  ;***********************************************************
   281                                  	; load the the kernel into memory
   282 00000147 E8C9FE                  	call 	load_kernel
   283 0000014A E88E00                  	call 	turn_off_floppy_motor
   284                                  
   285                                  	;interrupts will not be enabled again until protect mode
   286 0000014D FA                      	cli
   287 0000014E E87100                  	call	enable_protect_mode
   288 00000151 EA[5C02]0800            	jmp		0x8:protect_mode_start		; jump to end of code using Descripter Table Addressing
   289                                  
   290                                  ;***********************************************************
   291                                  ;		Halt Execution
   292                                  ;***********************************************************
   293                                  fatal_failure:
   294 00000156 BE[E900]                	mov		si, cst_msg_fatal_failure
   295 00000159 E80600                  	call 	print
   296 0000015C B400                    	mov		ah,	0x00	; Both bios call use paramater 0
   297 0000015E CD16                    	int		0x16		; BIOS 0x16 AH=0x00 -> await keypress
   298 00000160 CD19                    	int		0x19		; BIOS 0x19 AH=0x00 ->warm boot computer
   299                                  
   300                                  
   301                                  ;***********************************************************
   302                                  ;	print:
   303                                  ;	- Prints a string
   304                                  ;	assumes
   305                                  ;	- address of first character is in DS:SI
   306                                  ;	last character is /0 (NULL)
   307                                  ;***********************************************************
   308                                  print:
   309 00000162 AC                      	lodsb					; Load DS:SI into AL for proccessing
   310 00000163 08C0                    	or		al, al 			; this can only set the zero flag if AL is NULL
   311 00000165 7406                    	jz		end_print		; if zero flag is set
   312 00000167 B40E                    	mov		ah, 0eh			; Bios paramaeter
   313 00000169 CD10                    	int		10h				; Bios function
   314 0000016B EBF5                    	jmp		print			; repeat until null terminator is found.
   315                                  end_print:
   316 0000016D C3                      	ret
   317                                  
   318                                  ;***********************************************************
   319                                  ;		enable_a20_keyboard_out:
   320                                  ;		- enable the a20 line
   321                                  ;		- Uses the keyboard controller out port method
   322                                  ;***********************************************************
   323                                  enable_a20_keyboard_out:
   324 0000016E FA                      	cli						;stop interupts
   325 0000016F 60                      	pusha					;save state of all registers
   326 00000170 E85A00                  	call 	wait_for_clear_input
   327 00000173 B0AD                    	mov     al,0xAD
   328 00000175 E664                    	out     0x64,al			; disable the keyboard
   329 00000177 E85300                  	call 	wait_for_clear_input
   330                                  
   331 0000017A B0D0                    	mov     al,0xD0
   332 0000017C E664                    	out     0x64,al			; tell controller to read key board output port
   333 0000017E E85300                  	call    wait_for_clear_output
   334                                  
   335 00000181 E460                    	in      al,0x60
   336 00000183 6650                    	push    eax				; get output port data and store it
   337 00000185 E84500                  	call 	wait_for_clear_input
   338                                  
   339 00000188 B0D1                    	mov     al,0xD1
   340 0000018A E664                    	out     0x64,al			; tell controller to write to output port
   341 0000018C E83E00                  	call 	wait_for_clear_input
   342                                  
   343 0000018F 6658                    	pop     eax
   344 00000191 0C02                    	or      al,2			; set bit 1 (enable a20)
   345 00000193 E660                    	out     0x60,al			; write out data back to the output port
   346                                  
   347 00000195 E83500                  	call 	wait_for_clear_input
   348 00000198 B0AE                    	mov     al,0xAE			; enable the keyboard
   349 0000019A E664                    	out     0x64,al
   350                                  
   351 0000019C E82E00                  	call 	wait_for_clear_input
   352 0000019F 61                      	popa
   353 000001A0 FB                      	sti
   354 000001A1 C3                      	ret
   355                                  
   356                                  ;***********************************************************
   357                                  ;	note- we must set es and ds so that the later copy above 1mb works
   358                                  ;	cached descriptors will persist even after the original descriptor is
   359                                  ;	restored.
   360                                  ;***********************************************************
   361                                  enable_unreal_mode:
   362 000001A2 FA                      	cli
   363 000001A3 1E                      	push 	ds
   364 000001A4 06                      	push	es
   365                                  
   366 000001A5 0F0116[0301]            	lgdt 	[gdtr]        	; load GDT into GDTR
   367 000001AA 0F20C0                  	mov  	eax, cr0		; switch to pmode by
   368 000001AD 0C01                    	or 		al,1			; set pmode bit
   369 000001AF 0F22C0                  	mov  	cr0, eax
   370                                  
   371 000001B2 BB1000                  	mov  	bx, 0x10		; select descriptor 2
   372 000001B5 8EDB                    	mov  	ds, bx			; 10h = 1 0000b
   373 000001B7 8EC3                    	mov  	es, bx			; 10h = 1 0000b
   374                                  
   375 000001B9 24FE                    	and 	al,0xFE			; back to realmode
   376 000001BB 0F22C0                  	mov  	cr0, eax		; by toggling bit again
   377                                  
   378 000001BE 07                      	pop		es
   379 000001BF 1F                      	pop 	ds				; get back old segment
   380 000001C0 FB                      	sti
   381 000001C1 C3                      	ret
   382                                  
   383                                  enable_protect_mode:
   384 000001C2 0F20C0                  	mov	eax, cr0		; set bit 0 in cr0--enter pmode
   385 000001C5 6683C801                	or	eax, 1
   386 000001C9 0F22C0                  	mov	cr0, eax
   387 000001CC C3                      	ret
   388                                  
   389                                  wait_for_clear_input:	;wait for a clear input buffer
   390 000001CD E464                    	in      al,0x64
   391 000001CF A802                    	test    al,2
   392 000001D1 75FA                    	jnz     wait_for_clear_input
   393 000001D3 C3                      	ret
   394                                  
   395                                  wait_for_clear_output:	;wait for a clear output buffer
   396 000001D4 E464                    	in      al,0x64
   397 000001D6 A801                    	test    al,1
   398 000001D8 74FA                    	jz      wait_for_clear_output
   399 000001DA C3                      	ret
   400                                  
   401                                  ;***********************************************************
   402                                  ; Turn off flopy motor
   403                                  ;***********************************************************
   404                                  turn_off_floppy_motor:
   405 000001DB BAF203                  	mov	dx, 0x03F2
   406 000001DE B00C                    	mov	al, 0x0C
   407 000001E0 EE                      	out	dx, al
   408 000001E1 C3                      	ret
   409                                  
   410                                  ;***********************************************************
   411                                  ; Protect Mode starts here
   412                                  ;***********************************************************
   413                                  bits 32
   414                                  
   415                                  %include "enable_paging.asm"
   416                              <1> ;**********************************************************
   417                              <1> ;	bluefire-os
   418                              <1> ;	Version: 00.00.03
   419                              <1> ;	Author: David Davidson
   420                              <1> ;	Name: enable_paging.asm
   421                              <1> ;	Last update: 2012-01-10
   422                              <1> ;	Purpose:
   423                              <1> ;	Usage: Must be in protect mode.
   424                              <1> ;***********************************************************
   425                              <1> 
   426                              <1> ; Tell assembler to generate 32 bit byte code. Any code in this
   427                              <1> ; Module must be called after in Protect mode.
   428                              <1> [BITS 32]
   429                              <1> 
   430                              <1> ; Kernel virtual start address
   431                              <1> %define K_VIR_START	0xC0000000
   432                              <1> 
   433                              <1> ;Kernel physiscal start address
   434                              <1> %define K_PHYS_START	0x100000
   435                              <1> 
   436                              <1> ; Paging constants
   437                              <1> %define	P_PRESENT 	0x01
   438                              <1> %define P_WRITE		0x02
   439                              <1> %define P_USER		0x04
   440                              <1> %define PAGE_SIZE	0x1000
   441                              <1> 
   442                              <1> ; TODO -> document memory map
   443                              <1> %define K_PDE		0x1000	; Page directory
   444                              <1> %define K_PTE		0x2000	; Kernel page table #0 (4MB)
   445                              <1> %define I_PTE		0x3000	; First 4MB Identity-map page table
   446                              <1> 
   447                              <1> %macro memset 3
   448                              <1> ; void memset(void *dest_ptr, int val, dword count);
   449                              <1> ; o32 a32 forces the opperand and addressing of the string command into 32 bit mode.
   450                              <1> 	mov edi, %1
   451                              <1> 	mov eax, %2
   452                              <1> 	mov ecx, %3
   453                              <1> 	cld
   454                              <1> 	o32 a32 rep stosb
   455                              <1> %endmacro
   456                              <1> 
   457                              <1> %macro memcpy 3
   458                              <1> ; void memcpy(void *dest_ptr, void *org_ptr, dword count);
   459                              <1> 	mov edi, %1
   460                              <1> 	mov esi, %2
   461                              <1> 	mov ecx, %3
   462                              <1> 	cld
   463                              <1> 	o32 a32 rep movsb
   464                              <1> %endmacro
   465                              <1> 
   466                              <1> setup_and_enable_paging:
   467                              <1> 	; Zero out the future page directory, so there are no random entries
   468                              <1> 	; pointing to phantom memory
   469                              <1> 	; -> 0x1000 - 0x1FFF : 0x0
   470                              <1> 	memset K_PDE, 0, PAGE_SIZE
   471                              <2> 
   472                              <2> 
   473 000001E2 BF00100000          <2>  mov edi, %1
   474 000001E7 B800000000          <2>  mov eax, %2
   475 000001EC B900100000          <2>  mov ecx, %3
   476 000001F1 FC                  <2>  cld
   477 000001F2 F3AA                <2>  o32 a32 rep stosb
   478                              <1> 
   479                              <1> ;***********************************************************
   480                              <1> ; Set up the first 4MB as identity mapped memory.
   481                              <1> ; memory written here will write to the same physical location
   482                              <1> ; 0x00000000-0x003fffff -> 0x0000000000000000-0x00000000003fffff
   483                              <1> ;***********************************************************
   484                              <1> 	;          Fill      :     With
   485                              <1> 	; -> 0x3000 - 0x3FFF : 0x0(0 - 3FF)003
   486 000001F4 B803000000          <1> 	mov	eax, (P_PRESENT | P_WRITE)
   487 000001F9 B900040000          <1> 	mov	ecx, 1024
   488 000001FE BF00300000          <1> 	mov	edi, I_PTE
   489 00000203 FC                  <1> 	cld
   490                              <1> 	; Fill the page table.
   491                              <1> Map_I_PTE:
   492 00000204 AB                  <1> 	stosd
   493 00000205 0500100000          <1> 	add	eax, PAGE_SIZE
   494 0000020A E2F8                <1> 	loop	Map_I_PTE
   495                              <1> 	; Write the filled page table in the page directory.
   496                              <1> 	; -> 0x1000 : 0x3007
   497 0000020C C70500100000073000- <1> 	mov dword [K_PDE], I_PTE | P_PRESENT | P_WRITE | P_USER
   498 00000215 00                  <1>
   499                              <1> 
   500                              <1> ;***********************************************************
   501                              <1> ; Set up the kernel page table. The 4 MB starting at 1 MB as mapped to
   502                              <1> ; Logical addresses starting with 0xC to physical addresses 0x + 1MB.
   503                              <1> ; So writing to 0xC0000001 will put it in physical location 0x00010001
   504                              <1> ; 0xc0000000-0xc03fffff -> 0x0000000000100000-0x00000000004fffff
   505                              <1> ;***********************************************************
   506                              <1> 	;          Fill      :     With
   507                              <1> 	; -> 0x2000 - 0x2FFF : 0x0(100 - 4FF)003
   508 00000216 B803001000          <1> 	mov	eax, (K_PHYS_START | P_PRESENT | P_WRITE)
   509 0000021B B900040000          <1> 	mov	ecx, 1024
   510 00000220 BF00200000          <1> 	mov	edi, K_PTE
   511                              <1> 	; Fill the page table.
   512                              <1> Map_K_PTE:
   513 00000225 AB                  <1> 	stosd
   514 00000226 0500100000          <1> 	add	eax, PAGE_SIZE
   515 0000022B E2F8                <1> 	loop	Map_K_PTE
   516                              <1> 	; Write the filled page table in the page directory.
   517                              <1> 	; -> 0x1C00 : 0x2007
   518 0000022D C705001C0000072000- <1> 	mov dword [K_PDE+(K_VIR_START/(PAGE_SIZE*1024))*4], K_PTE | P_PRESENT | P_WRITE | P_USER
   519 00000236 00                  <1>
   520                              <1> 
   521                              <1> 
   522                              <1> ;
   523                              <1> ;***********************************************************
   524                              <1> ; Map page directory into itself. this allows no maintenance while ensuring
   525                              <1> ; page directory sanity, if it is manipulted as it acts as its own page table.
   526                              <1> ; 0xfffff000-0xffffffff -> 0x0000000000001000-0x0000000000001fff
   527                              <1> ; 0xfff00000-0xfff00fff -> 0x0000000000002000-0x0000000000002fff
   528                              <1> ; 0xffc00000-0xffc00fff -> 0x0000000000003000-0x0000000000003fff
   529                              <1> ;***********************************************************
   530                              <1> 	; -> 0x1FFC : 0x1007
   531 00000237 C705FC1F0000071000- <1> 	mov dword [K_PDE+1023*4], K_PDE | P_PRESENT | P_WRITE | P_USER
   532 00000240 00                  <1>
   533                              <1> 
   534                              <1> ;***********************************************************
   535                              <1> ; Enable paging
   536                              <1> ;***********************************************************
   537                              <1> 	; Setup the Page Directory Base Register
   538 00000241 B800100000          <1> 	mov	eax, K_PDE
   539 00000246 0F22D8              <1> 	mov	cr3, eax
   540                              <1> 	; enable
   541 00000249 0F20C0              <1> 	mov	eax, cr0
   542 0000024C 0D00000180          <1> 	or	eax, 0x80010000 ; CR0.PG = CR0.WP = 1
   543 00000251 0F22C0              <1> 	mov	cr0, eax
   544                              <1> 
   545                              <1> ; The registers are set on jump so a self jump is executed
   546 00000254 EA[5B020000]0800    <1> 	jmp	0x08:paging_enabled
   547                              <1> 
   548                              <1> paging_enabled:
   549                              <1> 
   550 0000025B C3                  <1> 	ret
   551                                  
   552                                  protect_mode_start:
   553                                  ;***********************************************************
   554                                  ;   Set segment registers
   555                                  ;***********************************************************
   556 0000025C 66B81000                	mov	ax, 0x10	; set data segments to data selector
   557 00000260 8ED8                    	mov	ds, ax
   558 00000262 8ED0                    	mov	ss, ax
   559 00000264 8EC0                    	mov	es, ax
   560 00000266 BCFFFF0900              	mov	esp, 9FFFFh		; Reset the stack, same place, new address mode
   561                                  
   562 0000026B E872FFFFFF              	call setup_and_enable_paging
   563                                  
   564                                  ;***********************************************************
   565                                  ;   Execute Kernel
   566                                  ;***********************************************************
   567                                  	; Pass amount of system memory hard coded for now but
   568                                  	; will be calulated later.
   569 00000270 FF35[FF000000]          	push DWORD [var_system_memory_amount]
   570                                  	; we have to save the address in case the kernel
   571                                  	; executes a ret with the proper stack
   572 00000276 68[82020000]            	push fatal_bootstrap_return
   573                                  	; jump to our kernel! It should be at 0xC0000000
   574 0000027B EA000000C00800          	jmp	0x8:0xC0000000
   575                                  
   576                                  ;***********************************************************
   577                                  ;	If we make it here then kernel returned with out permission
   578                                  ;   Stop execution and halt
   579                                  ;***********************************************************
   580                                  fatal_bootstrap_return:
   581 00000282 FA                      	cli
   582 00000283 F4                      	hlt
   583                                  
