     1                                  ;**********************************************************
     2                                  ;	bluefire-os
     3                                  ;	Version: 00.00.02
     4                                  ;	Author: David Davidson
     5                                  ;	Name: stage2.asm
     6                                  ;	Last update: 2011-11-20
     7                                  ;	Purpose: Enable A20 Line, Load GDT, enable protect mode, enable paging.
     8                                  ;		Load a kernel to physical memory location 0x100000
     9                                  ;***********************************************************
    10                                  
    11                                  ;***********************************************************
    12                                  ;	As in stage 1 we are still generating 16 bit code as
    13                                  ;	it will be running in real mode for now
    14                                  ;***********************************************************
    15                                  bits 16
    16                                  
    17                                  ;***********************************************************
    18                                  ;	To keep things interesting we are going to use the other
    19                                  ;	addressing technique. We are going to set our segment registers
    20                                  ;	to 0 and have all addresses in the code prefix with 0x8000
    21                                  ;***********************************************************
    22                                  org 0x8000
    23 00000000 E91A01                  start:	jmp main	;jump over to first byte of executable code
    24                                  
    25                                  %include "load_kernel.asm"
    26                              <1> ;**********************************************************
    27                              <1> ;	bluefire-os
    28                              <1> ;	Version: 00.00.03
    29                              <1> ;	Author: David Davidson
    30                              <1> ;	Name: load_kernel.asm
    31                              <1> ;	Last update: 2011-11-20
    32                              <1> ;	Purpose: To load a kernel from a fixed location on a floppy
    33                              <1> ;			to a fixed location in upper memory.
    34                              <1> ;	Usage: Unreal mode must have been enabled. Memory location 0x10000
    35                              <1> ;			must be availabel for use as a buffer. Kernel must be flat
    36                              <1> ;			arrayed on floppy sectors 800 to 2800
    37                              <1> ;***********************************************************
    38                              <1> 
    39                              <1> 
    40                              <1> ; ------ The physical description of a floppy ------
    41                              <1> ; The constants that represent the structure of a floppy drive
    42 00000003 00                  <1> cst_drive_number			DB	0		; We only support floppy drive A
    43 00000004 0200                <1> cst_heads_per_cylinder		DW	2		; A floppy can only have one plater (height of data)
    44 00000006 1200                <1> cst_sectors_per_track		DW	18		; A floppy has fixed amt of sectors on a track	(width of data)
    45 00000008 0002                <1> cst_bytes_per_sector		DW 	512		; evrey sector has 512 bytes init (density of data)
    46                              <1> 
    47                              <1> ; ------ Memory locations used as variables ------
    48                              <1> ;Variables used to return values from function LBACHS
    49 0000000A 00                  <1> calculated_sector 			DB 0x00
    50 0000000B 00                  <1> calculated_head   			DB 0x00
    51 0000000C 00                  <1> calculated_cylinder			DB 0x00
    52                              <1> 
    53                              <1> ; ------ Memory locations used as counters ------
    54                              <1> ; Starting location of kernel on disk. Fixed by build script.
    55 0000000D 2003                <1> var_current_disk_sector			DW 800
    56                              <1> ; Running counter of where in upper memory the kernel is currently
    57                              <1> ; being loaded. The segment is increased to keep the counter from
    58                              <1> ; increasing past a number that can be handled by 16 bits.
    59 0000000F 0000                <1> var_current_buffer_segment		DW 0
    60                              <1> ; Running counter of how many groups of disk sectors are left to load.
    61 00000011 1000                <1> var_sector_groups_left_to_load	DW 0x10
    62                              <1> 
    63                              <1> 
    64                              <1> load_kernel:
    65                              <1> 	; Since unreal mode is activated the code can access above 1 MB but
    66                              <1> 	; the bois interrupts that are needed to load the data off the disk
    67                              <1> 	; can only be used as if in real mode. So the code Loads
    68                              <1> 	; 16 groups of 125 disk blocks from the floppy to upper memory
    69                              <1> 	; using lower memory for each chunk.
    70                              <1> 	.load_kenel_loop:
    71                              <1> 		; --------------------------------------------------
    72                              <1> 		; Load a group of 125 disk sectors to lower memory
    73                              <1> 		; --------------------------------------------------
    74                              <1> 
    75                              <1> 		; use 1000:0000(0x10000) as the low memory buffer
    76 00000013 B80010              <1> 		mov		ax, 0x1000
    77 00000016 8EC0                <1> 		mov		es, ax
    78 00000018 BB0000              <1> 		mov		bx, 0x0000
    79                              <1> 		; load the 125 disk sectors we are up to
    80 0000001B A1[0D00]            <1> 		mov		ax, [var_current_disk_sector]
    81 0000001E B97D00              <1> 		mov		cx, 125
    82                              <1> 
    83 00000021 E83500              <1> 		call	read_sectors
    84                              <1> 
    85                              <1> 		; --------------------------------------------------
    86                              <1> 		; Copy the buffer to upper memory
    87                              <1> 		; --------------------------------------------------
    88                              <1> 
    89                              <1> 		; load the current running upper memory address
    90 00000024 A1[0F00]            <1> 		mov		ax, [var_current_buffer_segment]
    91 00000027 8EC0                <1> 		mov		es, ax
    92                              <1> 
    93                              <1> 		; Initalize source segment to be safe
    94 00000029 B80000              <1> 		mov 	ax, 0
    95 0000002C 8ED8                <1> 		mov		ds, ax
    96                              <1> 
    97                              <1> 		; The source is 1000:0000 (0x10000), the destination is es:0x100000
    98 0000002E 66BE00000100        <1> 		mov		esi, 0x10000
    99 00000034 66BF00001000        <1> 		mov		edi, 0x100000
   100                              <1> 		; copy the whole (sector group X sector size (125 x 512 =  0xFA00)) buffer
   101 0000003A 66B900FA0000        <1> 		mov		ecx, 0xFA00
   102                              <1> 		; we are using unreal memory location in real mode so we use the menomic a32
   103                              <1> 		; to generate 32 bit code.
   104 00000040 F367A4              <1> 		a32 	rep	 movsb
   105                              <1> 
   106                              <1> 		;inc counters
   107 00000043 8306[0D00]7D        <1> 		add	word [var_current_disk_sector], 125
   108 00000048 8106[0F00]A00F      <1> 		add word [var_current_buffer_segment], 0xFA0
   109                              <1> 
   110                              <1> 		;check iteration
   111 0000004E 8B0E[1100]          <1> 		mov		cx,  [var_sector_groups_left_to_load]
   112 00000052 FF0E[1100]          <1> 		dec		word [var_sector_groups_left_to_load]
   113 00000056 E2BB                <1> 		loop .load_kenel_loop
   114                              <1> 
   115 00000058 C3                  <1> 	ret
   116                              <1> 
   117                              <1> 
   118                              <1> ;***********************************************************
   119                              <1> ;	read_sectors:
   120                              <1> ;	-> AX 		=> Starting Sector
   121                              <1> ;	-> CX 		=> Amount of sectors to read
   122                              <1> ;				The buffer is segment limited so
   123                              <1> ;				must be less then or equal to 128 or buffer
   124                              <1> ;				will wrap over.
   125                              <1> ;	-> ES:BX 	=> Buffer to read to
   126                              <1> ;***********************************************************
   127                              <1> read_sectors:
   128                              <1> 	.read_sectors_start:
   129 00000059 BF0500              <1> 		mov		di,0x0005						; Five retries in case of error
   130                              <1> 	.sector_loop:
   131 0000005C 50                  <1> 		push 	ax								; Save the registers that we are going to use.
   132 0000005D 53                  <1> 		push 	bx
   133 0000005E 51                  <1> 		push 	cx
   134 0000005F E83600              <1> 		call LBACHS								; Calculate what the starting sector is
   135 00000062 B402                <1> 		mov     ah, 0x02						; 02 Bios read sector function
   136 00000064 B001                <1> 		mov     al, 0x01 						; Read one sector at a time
   137 00000066 8A2E[0C00]          <1> 		mov     ch, BYTE [calculated_cylinder]	; cylinder as returned by LBACHS
   138 0000006A 8A0E[0A00]          <1>         mov     cl, BYTE [calculated_sector]	; sector as returned by LBACHS
   139 0000006E 8A36[0B00]          <1>         mov     dh, BYTE [calculated_head]		; head as returned by LBACHS
   140 00000072 8A16[0300]          <1>         mov     dl, BYTE [cst_drive_number]		; drive is always 0
   141 00000076 CD13                <1> 		int     0x13							; invoke BIOS 0x13 AH=0x02
   142 00000078 730D                <1> 		jnc     .success                        ; test carry flag against a read error
   143 0000007A 31C0                <1> 		xor     ax, ax							; 0 is BIOS reset disk
   144 0000007C CD13                <1> 		int     0x13							; invoke BIOS 0x13 AH=0x00
   145 0000007E 4F                  <1> 		dec     di								; decrement error counter
   146 0000007F 59                  <1> 		pop     cx
   147 00000080 5B                  <1> 		pop     bx
   148 00000081 58                  <1> 		pop     ax
   149 00000082 75D8                <1> 		jnz     .sector_loop 					; if less the 5 tries, attempt to read again
   150 00000084 E8C100              <1> 		call 	fatal_failure
   151                              <1> 	.success:
   152 00000087 BE[E700]            <1> 		mov     si, cst_msg_progress
   153 0000008A E8C700              <1> 		call    print
   154 0000008D 59                  <1> 		pop     cx
   155 0000008E 5B                  <1> 		pop     bx
   156 0000008F 58                  <1> 		pop     ax
   157 00000090 031E[0800]          <1> 		add     bx, WORD [cst_bytes_per_sector] ; queue next buffer
   158 00000094 40                  <1> 		inc     ax                              ; queue next sector
   159 00000095 E2C2                <1> 		loop    .read_sectors_start             ; Decreases CX and jums if not zero.
   160 00000097 C3                  <1> 		ret
   161                              <1> 
   162                              <1> 
   163                              <1> ;***********************************************************
   164                              <1> ; 	LBACHS
   165                              <1> ;	Convert LBA to CHS
   166                              <1> ; 	AX -> LBA Address to convert
   167                              <1> ;
   168                              <1> ;	Returns <-
   169                              <1> ; 		calculated_sector 	= (logical sector mod sectors per track) + 1
   170                              <1> ; 		calculated_head   	= (logical sector / sectors per track) MOD number of heads
   171                              <1> ; 		calculated_cylinder = logical sector / (sectors per track * number of heads)
   172                              <1> ;
   173                              <1> ;***********************************************************
   174                              <1> LBACHS:
   175 00000098 31D2                <1>     xor     dx, dx                              ; Zero out dx
   176 0000009A F736[0600]          <1>     div     WORD [cst_sectors_per_track]		; Calculate sector against DX:AX store quotient->AX remainder->DX
   177 0000009E FEC2                <1>     inc     dl                                  ; Adjust for sector 0
   178 000000A0 8816[0A00]          <1>     mov     BYTE [calculated_sector], dl		; Store the result.
   179 000000A4 31D2                <1>     xor     dx, dx                              ; Zero out dx
   180 000000A6 F736[0400]          <1>     div     WORD [cst_heads_per_cylinder]		; calculate sector against DX:AX store quotient->AX remainder->DX
   181 000000AA 8816[0B00]          <1>     mov     BYTE [calculated_head], dl			; Store the result.
   182 000000AE A2[0C00]            <1>     mov     BYTE [calculated_cylinder], al		; Store the result.
   183 000000B1 C3                  <1> 	ret
   184                                  
   185                                  ; ------ Mesages ------
   186                                  ;0x0A ascii for next line.  0x0D cursor to the beggining of the line.
   187 000000B2 0D0A4C6F6164696E67-     cst_msg_loading 			DB 0x0D, 0x0A, "Loading Stage 2...", 0x0D, 0x0A, 0x00
   188 000000BB 20537461676520322E-
   189 000000C4 2E2E0D0A00         
   190 000000C9 0D0A57656C6F636D65-     cst_msg_unreal	 			DB 0x0D, 0x0A, "Welocme to unreal mode...", 0x0D, 0x0A, 0x00
   191 000000D2 20746F20756E726561-
   192 000000DB 6C206D6F64652E2E2E-
   193 000000E4 0D0A00             
   194                                  ; print one dot for every disk sector we load
   195 000000E7 2E00                    cst_msg_progress 			DB ".", 0x00
   196                                  ; Fatal
   197 000000E9 0D0A466174616C2046-     cst_msg_fatal_failure  		DB 0x0D, 0x0A, "Fatal Failure.....", 0x0A, 0x00
   198 000000F2 61696C7572652E2E2E-
   199 000000FB 2E2E0A00           
   200                                  
   201                                  ;***********************************************************
   202                                  ; Global Descriptor Register (GDR)
   203                                  ;***********************************************************
   204                                  gdtr:
   205 000000FF 1700                    	dw end_of_gdt - gdt_data - 1 	; limit (Size of GDT)
   206 00000101 [05010000]              	dd gdt_data 			; base of GDT
   207                                  ;***********************************************************
   208                                  ; Global Descriptor Table (GDT)
   209                                  ;***********************************************************
   210                                  gdt_data:
   211                                  ; Dummy descriptor			; 0x00
   212 00000105 0000                    	DW 0					; Limit low (bytes 15:0)
   213 00000107 0000                    	DW 0					; Base low (bytes 15:0)
   214 00000109 00                      	DB 0					; Base middle (bytes 23:16)
   215 0000010A 00                      	DB 0					; Access byte (descriptor type)
   216 0000010B 00                      	DB 0					; Flags, Limit middle (bytes 19:16)
   217 0000010C 00                      	DB 0					; Base high (bytes 31:24)
   218                                  ; boot code:				; code descriptor
   219 0000010D FFFF                    	DW 0xFFFF           	; Limit (bytes 15:0)
   220 0000010F 0000                    	DW 0                	; Base  (bytes 15:0)
   221 00000111 00                      	DB 0                	; Base  (bytes 23:16)
   222 00000112 9A                      	DB 0b10011010        	; access  = Present, Ring 0, 1, Executable, Direction, Readable, Unaccessed (1,00,1,1110 -> 9A)
   223 00000113 CF                      	DB 0b11001111        	; granularity = 4KB Granularity, 32bit segment size, reserved, reserved (AVL), Limit (bytes 19:16) (1,1,0,0,1111 - > CF)
   224 00000114 00                      	DB 0                	; Base  (bytes 31:24)
   225                                  ; boot data:	        	; data descriptor
   226 00000115 FFFF                    	DW 0xFFFF           	; Limit (bytes 15:0)
   227 00000117 0000                    	DW 0                	; Base  (bytes 15:0)
   228 00000119 00                      	DB 0                	; Base  (bytes 23:16)
   229 0000011A 92                      	DB 0b10010010        	; access  = Present, Ring 0, 1, Not Executable, No Direction, Readable, Unaccessed (1,00,1,0010 -> 92)
   230 0000011B CF                      	DB 0b11001111        	; granularity = 4KB Granularity, 32bit segment size, reserved, reserved (AVL), Limit (bytes 19:16) (1,1,0,0,1111 - > CF)
   231 0000011C 00                      	DB 0                	; Base  (bytes 31:24)
   232                                  end_of_gdt:
   233                                  
   234                                  main:
   235 0000011D FA                      	cli						; clear interrupts
   236                                  
   237                                  ;***********************************************************
   238                                  ;	Set the segment registers back to 0x0000 as aformentioned
   239                                  ;	As we are now using the org directive to hard code the address offsets
   240                                  ;	The stack is staying at 000F:FFFF and should be empty at this point
   241                                  ;	but we set it again to be safe
   242                                  ;***********************************************************
   243 0000011E 31C0                    	xor		ax, ax			; null segments
   244 00000120 8ED8                    	mov		ds, ax
   245 00000122 8EC0                    	mov		es, ax
   246 00000124 8EE0                    	mov		fs, ax
   247 00000126 8EE8                    	mov		gs, ax
   248                                  
   249 00000128 B80090                  	mov 	ax, 0x9000
   250 0000012B 8ED0                    	mov		ss, ax
   251 0000012D BCFFFF                  	mov		sp, 0xFFFF
   252 00000130 FB                      	sti						; restore interupts we need them before we can make any bios call
   253                                  
   254                                  ;***********************************************************
   255                                  ;	Display welcome message
   256                                  ;***********************************************************
   257 00000131 BE[B200]                	mov		si, cst_msg_loading
   258 00000134 E81D00                  	call	print
   259                                  
   260                                  ;***********************************************************
   261                                  ;	Allow more than 1MB to be accessed
   262                                  ;	Enable the A20 line
   263                                  ;	Enable Unreal mode
   264                                  ;
   265                                  ;***********************************************************
   266 00000137 E82600                  	call 	enable_a20_keyboard_out
   267 0000013A E85700                  	call 	enable_unreal_mode
   268 0000013D BE[C900]                	mov		si, cst_msg_unreal
   269 00000140 E81100                  	call	print
   270                                  
   271                                  
   272                                  ;***********************************************************
   273                                  ;	Load the kernel into memory
   274                                  ;
   275                                  ;***********************************************************
   276                                  	; load the the kernel into memory
   277 00000143 E8CDFE                  	call 	load_kernel
   278                                  
   279                                  end:
   280 00000146 EBFE                    	jmp 	end				;stop here for now
   281                                  
   282                                  ;***********************************************************
   283                                  ;		Halt Execution
   284                                  ;***********************************************************
   285                                  fatal_failure:
   286 00000148 BE[E900]                	mov		si, cst_msg_fatal_failure
   287 0000014B E80600                  	call print
   288 0000014E B400                    	mov		ah,	0x00	; Both bios call use paramater 0
   289 00000150 CD16                    	int		0x16		; BIOS 0x16 AH=0x00 -> await keypress
   290 00000152 CD19                    	int		0x19		; BIOS 0x19 AH=0x00 ->warm boot computer
   291                                  
   292                                  
   293                                  ;***********************************************************
   294                                  ;	print:
   295                                  ;	- Prints a string
   296                                  ;	assumes
   297                                  ;	- address of first character is in DS:SI
   298                                  ;	last character is /0 (NULL)
   299                                  ;***********************************************************
   300                                  print:
   301 00000154 AC                      	lodsb					; Load DS:SI into AL for proccessing
   302 00000155 08C0                    	or		al, al 			; this can only set the zero flag if AL is NULL
   303 00000157 7406                    	jz		end_print		; if zero flag is set
   304 00000159 B40E                    	mov		ah, 0eh			; Bios paramaeter
   305 0000015B CD10                    	int		10h				; Bios function
   306 0000015D EBF5                    	jmp		print			; repeat until null terminator is found.
   307                                  end_print:
   308 0000015F C3                      	ret
   309                                  
   310                                  ;***********************************************************
   311                                  ;		enable_a20_keyboard_out:
   312                                  ;		- enable the a20 line
   313                                  ;		- Uses the keyboard controller out port method
   314                                  ;***********************************************************
   315                                  enable_a20_keyboard_out:
   316 00000160 FA                      	cli						;stop interupts
   317 00000161 60                      	pusha					;save state of all registers
   318 00000162 E84F00                  	call 	wait_for_clear_input
   319 00000165 B0AD                    	mov     al,0xAD
   320 00000167 E664                    	out     0x64,al			; disable the keyboard
   321 00000169 E84800                  	call 	wait_for_clear_input
   322                                  
   323 0000016C B0D0                    	mov     al,0xD0
   324 0000016E E664                    	out     0x64,al			; tell controller to read key board output port
   325 00000170 E84800                  	call    wait_for_clear_output
   326                                  
   327 00000173 E460                    	in      al,0x60
   328 00000175 6650                    	push    eax				; get output port data and store it
   329 00000177 E83A00                  	call 	wait_for_clear_input
   330                                  
   331 0000017A B0D1                    	mov     al,0xD1
   332 0000017C E664                    	out     0x64,al			; tell controller to write to output port
   333 0000017E E83300                  	call 	wait_for_clear_input
   334                                  
   335 00000181 6658                    	pop     eax
   336 00000183 0C02                    	or      al,2			; set bit 1 (enable a20)
   337 00000185 E660                    	out     0x60,al			; write out data back to the output port
   338                                  
   339 00000187 E82A00                  	call 	wait_for_clear_input
   340 0000018A B0AE                    	mov     al,0xAE			; enable the keyboard
   341 0000018C E664                    	out     0x64,al
   342                                  
   343 0000018E E82300                  	call 	wait_for_clear_input
   344 00000191 61                      	popa
   345 00000192 FB                      	sti
   346 00000193 C3                      	ret
   347                                  
   348                                  ;***********************************************************
   349                                  ;	note- we must set es and ds so that the later copy above 1mb works
   350                                  ;***********************************************************
   351                                  enable_unreal_mode:
   352 00000194 FA                      	cli
   353 00000195 1E                      	push 	ds
   354 00000196 06                      	push	es
   355                                  
   356 00000197 0F0116[FF00]            	lgdt 	[gdtr]        	; load GDT into GDTR
   357 0000019C 0F20C0                  	mov  	eax, cr0		; switch to pmode by
   358 0000019F 0C01                    	or 		al,1			; set pmode bit
   359 000001A1 0F22C0                  	mov  	cr0, eax
   360                                  
   361 000001A4 BB1000                  	mov  	bx, 0x10		; select descriptor 2
   362 000001A7 8EDB                    	mov  	ds, bx			; 10h = 1 0000b
   363 000001A9 8EC3                    	mov  	es, bx			; 10h = 1 0000b
   364                                  
   365 000001AB 24FE                    	and 	al,0xFE			; back to realmode
   366 000001AD 0F22C0                  	mov  	cr0, eax		; by toggling bit again
   367                                  
   368 000001B0 07                      	pop		es
   369 000001B1 1F                      	pop 	ds				; get back old segment
   370 000001B2 FB                      	sti
   371 000001B3 C3                      	ret
   372                                  
   373                                  wait_for_clear_input:	;wait for a clear input buffer
   374 000001B4 E464                    	in      al,0x64
   375 000001B6 A802                    	test    al,2
   376 000001B8 75FA                    	jnz     wait_for_clear_input
   377 000001BA C3                      	ret
   378                                  
   379                                  wait_for_clear_output:	;wait for a clear output buffer
   380 000001BB E464                    	in      al,0x64
   381 000001BD A801                    	test    al,1
   382 000001BF 74FA                    	jz      wait_for_clear_output
   383 000001C1 C3                      	ret
   384                                  
   385                                  
