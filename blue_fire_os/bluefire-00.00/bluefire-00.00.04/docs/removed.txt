-------------------------------------------------------------------------------------
paging.c
-------------------------------------------------------------------------------------
/**************************************************************************
*	Sets up everything we need for paging
**************************************************************************/
void initialize_paging() {
	// TODO flush the tlb?
	u32int addr;

	// Initialize free frames stack
	init_free_frames();

	// Every process assumes it has the first 3GB of memory to its self. Until now
	// lower memory was identity mapped so 0x1000(V) = 0x1000(P) while the page directory that resided in it
	// was self mapped and addressable as either 0x1000(V) or 0xFFFFF000(V) both mapping to 0x1000(P). Now Lower
	// memory will be unmaped and only the self mapped will work.
	// -> 0xFFFFF000 : 0x0
	*ADDR_TO_PDE(0) = NULL;

	// Map physical memory into the kernel address space
	// Map the physical addresses of the first 16 MB of memory to Virtual addresses 0xEF000000 to 0xF0000000
	for (addr=VIRTUAL_ACTUAL_MEMORY_START; addr<VIRTUAL_ACTUAL_MEMORY_END; addr+=PAGE_SIZE) {
		map_page(addr, addr-VIRTUAL_ACTUAL_MEMORY_START, P_PRESENT | P_WRITE);
	}

	// Initialize master page directory
	// The master page directory is a manually maintained record of the kernel's page directory
	// Processes will us it when they fork as a base of their page tables.
	for (addr=0; addr<1024; addr++) {
		K_PDBR[addr] = ((u32int *)VIRTUAL_PAGE_DIRECTORY_MAP)[addr];
	}
}

dbg(ADDR_TO_PDE(0))
	dbg(ADDR_TO_PDE(0xC0000000))
	dbg(ADDR_TO_PDE(0xFFC00000))
	dbg(ADDR_TO_PDE(0xEF000000))
	dbg(VIRT_TO_PDE_ADDR(0))
	dbg(VIRT_TO_PDE_ADDR(0xC0000000))
	dbg(VIRT_TO_PDE_ADDR(0xFFC00000))
	dbg(VIRT_TO_PDE_ADDR(0xEF000000))
-------------------------------------------------------------------------------------
paging.h
-------------------------------------------------------------------------------------
/**************************************************************************
*	Page look up routines
*	To find a page the kernel, the kernel must get values from two tables.
*	The first table is called the "Page Directory", each entry in it is called
*	a "Page Directory Entry (PDE)".
*	The Second table is called the "Page Table" which each entry called
*	a "Page Table Entry (PTE)".
*	To find to take a Virtual address and find find what physical address to read...
*	First,
*		the PDE is stored at 0x1000(P) which is addressable as 0xFFFFF000(V)
*	Next
*		the 4,294,967,295 bytes of addressable space is divided into 1,048,576 parts
*		and the proper entry is read from the PDE.
*		So for example... (0 = the first entry)  (C0000000 = the 3072 entry)
*	Next
*		the entry stored in that PDE is used as a physical address that represents the PTE
*		which is a block of 1024 4 bytes entries. That entry is the upper 20 bits of the physical
*		address while the lower 12 comes from the last bits of the virtual address.
*
*	The astute observer might note that this has turned one expensive memory operation in to 3.
*	The answer is the Translation Lookaside Buffer (TLB). In reality the TLB usually has a
*	99% hit rate but the downside is that it must be maintained.
**************************************************************************/

#define P_PRESENT	0x01
#define P_ACCESSED	0x20
#define P_DIRTY		0x40

// Divides the addressable space into 4096 parts and returns which part (addr) is in.
#define ADDR_TO_PDE(addr)	(u32int *)(VIRTUAL_PAGE_DIRECTORY_MAP + (((u32int) (addr) / (1024 * 1024))&(~0x3)))
-------------------------------------------------------------------------------------
start.asm
-------------------------------------------------------------------------------------
;***********************************************************
;	This is start.asm the first code to be run as part of the
;	kernel. It has two purposes...
;
;	First, re-run certain critical code that was already run in stage 2.
;	This might seem redundant but it is important for future growth as
;	even if the bootloader changes, all of the absolute requirements
; 	are self contained.
;
;	Second, implement any critical funtionality needed before
;	the kernels c code starts running. An intitial example is that
;	it moves the stack from lower memory, where it was needed for
;	bootloader access, to a location higher in memory where it will
;	only be usable by the kernel.
;***********************************************************
%define K_PDE			0x1000	; Page directory
%define K_PTE			0x2000	; Kernel page table #0 (4MB)
%define I_PTE			0x3000	; First 4MB Identity-map page table

; Write the filled page table in the page directory



; (K_VIR_START/(PAGE_SIZE*1024))*4 => (0xC0000000/(0x409000)) * 4
;mov dword [K_PAGE_DIR+(K_VIR_START/(PAGE_SIZE*1024))*4], K_PAGE_TAB | P_PRESENT | P_WRITE | P_USER
;mov dword [K_PAGE_DIR+(0xC0000000/(0x1000*0x400))*4], K_PAGE_TAB | P_PRESENT | P_WRITE | P_USER
;mov dword [K_PAGE_DIR+((0xC0000000/(0x400000))*0x4)], K_PAGE_TAB | P_PRESENT | P_WRITE | P_USER
;mov dword [K_PAGE_DIR+((0x300)*0x4)], K_PAGE_TAB | P_PRESENT | P_WRITE | P_USER
;mov dword [K_PAGE_DIR+1023*4], K_PAGE_DIR | P_PRESENT | P_WRITE | P_USER




;cr3: 0x000000001000
;0x00000000-0x003fffff -> 0x000000000000-0x0000003fffff
;0xc0000000-0xc03fffff -> 0x000000100000-0x0000004fffff
;0xffc00000-0xffc00fff -> 0x000000003000-0x000000003fff
;0xfff00000-0xfff00fff -> 0x000000002000-0x000000002fff
;0xfffff000-0xffffffff -> 0x000000001000-0x000000001fff


-------------------------------------------------------------------------------------
kernel_map.h
-------------------------------------------------------------------------------------

// the first 16MB of physical memory are mapped here
#define VIRTUAL_ACTUAL_MEMORY_START	0xEF000000
#define VIRTUAL_ACTUAL_MEMORY_END	0xEF000000
